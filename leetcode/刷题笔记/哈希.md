# 哈希

> 本章部分实验代码(ws/hash)

## 1. 简易哈希表

### １.lcNo:242 有效的字母异位词

题目：给定两个字符串 `s`和 `t`，编写一个函数来判断 `t`是否是 `s`的字母异位（注：若 `s`和 `t`中每个字符出现的次数都相同，则称 `s`和 `t`互为字母异位词。）

> 　　该问题明显可以用hash完成，但是这个时候一个简单数组就可以达到哈希效果。
>
> 代码如下：
>
> ```cpp
> bool isAnagram(string s, string t) {
>         int record[26]={0};
>         for(char c:s){
>           record[c-'a']++;
>         }
>         for(char c:t){
>           record[c-'a']--;
>         }
>         for(int i=0;i<26;i++){
>           if(record[i]) return false;
>         }
>         return true;
>     }
> ```

## 2. 复杂哈希表-unordered_map

### 1.lcNo:438 找到字符串中所有的字母异位词

题目：给定两个字符串 `s` 和 `p`，找到 `s` 中所有 **`p`**  的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

> 这道题采用窗口法，不过需要明确窗口的准备临界点是什么。这里不再采用简易的数组实现，而是引入 `unordered_map`来实现对哈希表的比较，通过一前一后两个索引实现窗口滑动。这里值得学习的是 `isValid`函数一个循环比较两个哈希表的方法。
>
> 代码如下：
>
> ```cpp
> bool isValid(unordered_map<char, int>& m1, unordered_map<char, int>& m2) {
>         for(auto c:m1){
>             if(c.second!=m2[c.first]){
>               return false;
>             }
>         }
>     return true;
>     }
>
>     vector<int> findAnagrams(string s, string p) {
>         unordered_map<char, int> cnt;
>         unordered_map<char, int> m;
>         for(auto c:p){
>           cnt[c]++;
>         }
>         int l=0;
>         int r=p.size()-1;
>         vector<int> ans;
>         for(int i=0;i<r;i++){
>           m[s[i]]++;
>         }
>         while(r<s.size()){
>           m[s[r]]++;
>           if(isValid(cnt,m)) ans.push_back(l);
>           m[s[l]]--;
>           l++;
>           r++;
>         }
>     return ans;
>     }
> ```

### 2. lcNo:383 赎金信

题目：

为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。给你一个赎金信 (`ransomNote`) 字符串和一个杂志(`magazine`)字符串，判断 `ransomNote` 能不能由 `magazines` 里面的字符构成。

如果可以构成，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次

> 这个问题要比lcNo：438简单。可以延续其比较两个哈希表是否相同的思路，不过这里并不是需要二者相同，而是 `magazine`比 `ransomeNote`要大于或等于。
>
> 代码如下：
>
> ```cpp
> bool canConstruct(string ransomNote, string magazine) {
>         unordered_map<char, int> magmap;
>         unordered_map<char, int> ransommap;
>         for(auto c:ransomNote){
>           ransommap[c]++;
>         }
>         for(auto c:magazine){
>           magmap[c]++;
>         }
>         for(auto c:ransommap){
>           if(c.second>magmap[c.first])return false;
>         }
>         return true;
>     }
> ```

## 3. 复杂哈希表-unordered_set

### 1. lcNo:349 两个数组的交集

题目：给定两个数组，编写一个函数来计算它们的交集。

> `set`和 `map`的区别在于 `set`只有 `key`而没有 `value`，因此适合用在这个题目。
>
> 代码如下：
>
> ```cpp
> vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
>         unordered_set<int> result;
>         unordered_set<int> num_set(nums1.begin(),nums1.end());
>         for(int num:nums2){
>           if(num_set.find(num)!=num_set.end()){
>             result.insert(num);
>           }
>         }
>         return vector<int>(result.begin(),result.end());
>     }
> ```
> 这里有一个细节，为何存放结构的result采用的是 `set`然后最后在转换为 `vector<int> `似乎多此一举，事实上本题最终要求输出的是一个**集合**，因此 `set`的不可重复性才能胜任这个功能。如果要不去重，并且结果中每个元素出现的次数等于二数组中重复的次数，可以见lcNo：350，采用 `map`或者双指针解决。
