# 哈希

> 本章部分实验代码(ws/hash)

## 1. 简易哈希表

### １.lcNo:242 有效的字母异位词

题目：给定两个字符串 `s`和 `t`，编写一个函数来判断 `t`是否是 `s`的字母异位（注：若 `s`和 `t`中每个字符出现的次数都相同，则称 `s`和 `t`互为字母异位词。）

> 　　该问题明显可以用hash完成，但是这个时候一个简单数组就可以达到哈希效果。
>
> 代码如下：
>
> ```cpp
> bool isAnagram(string s, string t) {
>         int record[26]={0};
>         for(char c:s){
>           record[c-'a']++;
>         }
>         for(char c:t){
>           record[c-'a']--;
>         }
>         for(int i=0;i<26;i++){
>           if(record[i]) return false;
>         }
>         return true;
>     }
> ```

## 2. 复杂哈希容

### 1.lcNo:438 找到字符串中所有的字母异位词

题目：给定两个字符串 `s` 和 `p`，找到 `s` 中所有 **`p`**  的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

> 这道题采用窗口法，不过需要明确窗口的准备临界点是什么。这里不再采用简易的数组实现，而是引入 `unordered_map`来实现对哈希表的比较，通过一前一后两个索引实现窗口滑动。这里值得学习的是 `isValid`函数一个循环比较两个哈希表的方法。
>
> 代码如下：
>
> ```cpp
> bool isValid(unordered_map<char, int>& m1, unordered_map<char, int>& m2) {
>         for(auto c:m1){
>             if(c.second!=m2[c.first]){
>               return false;
>             }
>         }
>     return true;
>     }
>
>     vector<int> findAnagrams(string s, string p) {
>         unordered_map<char, int> cnt;
>         unordered_map<char, int> m;
>         for(auto c:p){
>           cnt[c]++;
>         }
>         int l=0;
>         int r=p.size()-1;
>         vector<int> ans;
>         for(int i=0;i<r;i++){
>           m[s[i]]++;
>         }
>         while(r<s.size()){
>           m[s[r]]++;
>           if(isValid(cnt,m)) ans.push_back(l);
>           m[s[l]]--;
>           l++;
>           r++;
>         }
>     return ans;
>     }
> ```
