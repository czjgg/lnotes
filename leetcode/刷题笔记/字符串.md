# 字符串

> 本章部分实验代码(ws/string)

## 1. 更改字符串

### 1. lcNo：344 反转字符串

题目：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

> 当成数组操作就行

### 2. lcNo：541 反转字符串 ②

题目： 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

* 如果剩余字符少于`k` 个，则将剩余字符全部反转
* 如果剩余字符小于`2k` 但大于或等于`k` 个，则反转前`k` 个字符，其余字符保持原样。

> 其实可以用之前的函数实现

### 3. 剑指offer：05 替换空格

题目：请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

> **其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**
>
> 这么做有两个好处：
>
> 1. 不用申请新数组。
> 2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

### 4. lcNo：151 翻转字符串里的单词

题目：给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：

输入: "the sky is blue"

输出: "blue is sky the"

示例 2：

输入: "  hello world!  "

输出: "world! hello"

解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：

输入: "a good   example"

输出: "example good a"

解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

> 使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。
>
> 提高一下本题的难度：**不要使用辅助空间，空间复杂度要求为O(1)。**
>
> 解题思路如下：
>
> * 移除多余空格
> * 将整个字符串反转
> * 将每个单词反转

## 2. 统计字符串

### 1. lcNo: 28 实现 strStr()

题目：实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

示例 1:
输入: haystack = "hello", needle = "ll"
输出: 2

示例 2:
输入: haystack = "aaaaa", needle = "bba"
输出: -1

说明:
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

> 本题使用于KMP算法，达到$O(mn)$的时间复杂度。
>
> 具体步骤
>
> 1. 利用`needle`构建`next`前缀数组。
>    1. 初始化`next[0]=0，i=1，j=0`
>    2. 判断`needle[i]`与`next[j]`是否相等，如果不相等则往前迭代`j=next[j-1]`，直到满足条件或者`j=0`。
> 2. 获得`next`数组后，用同样的逻辑匹配`haystact`和`needle`直到`j`全部匹配完。

### 2. lcNo: 459 重复的子字符串

题目：

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:

输入: "abab"

输出: True

解释: 可由子字符串 "ab" 重复两次构成。

示例 2:

输入: "aba"

输出: False

示例 3:

输入: "abcabcabcabc"

输出: True

解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)

> 这道题提供了一个新的思路，就是构建 `next`数组不仅仅可以用于匹配，他还显示了一些其他的性质。
>
> 在这里很明显，如果满足 `len%(len-next[len-1])`这个条件，显然可以迭代证明整个字符串由前 `len-next[len-1]`个子字符串组成。
