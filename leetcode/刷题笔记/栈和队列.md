# 1. 栈和队列

> 本章部分实验代码(ws/stack_queue/sq)

## 1. 优先级队列

### 1. lcNo：347 前K个高频元素

题目：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

> 这道题目主要涉及到如下三块内容：
>
> 1. 要统计元素出现频率
> 2. 对频率排序
> 3. 找出前K个高频元素
>
> 第一个问题，可以用 `unordered_map`解决。第二个和第三个就必须用 `优先级队列(prior_queue)`一并解决，该数据结构兼具队列的进出数据的功能，也具有堆的功能将最小值或者最大值置于队列前端。如此以来，采用最小堆构成的优先级队列，通过不断的将最小值丢弃，保留剩下的 `K`个值，就是所求内容。

## 2. 单调队列

### 1. lcNo: 239 滑动窗口最大值

题目：给定一个数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

> 这道题采用单调队列的方法会比较好做，原因是？
>
> 设计单调队列的时候，pop，和push操作要保持如下规则：
>
> 1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
> 2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止
>
> 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。
